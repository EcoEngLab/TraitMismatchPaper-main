par(mfrow=c(3,1))
for(i in c(1,3,4)) acf(s1[,i], lag.max=20)
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 8 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
lf.fit.mcmc <- as.mcmc(lf.fit)
lf.fit$BUGSoutput$summary[1:5,]
plot(lf.fit.mcmc[,c(1,3,4)]) ## default coda plot
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
pdf=FALSE) ## from the MCMCvis package
s1<-as.data.frame(lf.fit.mcmc[[1]])
par(mfrow=c(3,1))
for(i in c(1,3,4)) acf(s1[,i], lag.max=20)
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
lf.fit.mcmc <- as.mcmc(lf.fit)
lf.fit$BUGSoutput$summary[1:5,]
plot(lf.fit.mcmc[,c(1,3,4)]) ## default coda plot
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
pdf=FALSE) ## from the MCMCvis package
s1<-as.data.frame(lf.fit.mcmc[[1]])
par(mfrow=c(3,1))
for(i in c(1,3,4)) acf(s1[,i], lag.max=20)
ipairs(s1[,c(1,3,4)], ztransf = function(x){x[x<1] <- 1; log2(x)})
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,42), data = lf.data.comb,
ylab = "Lifespan for Ae. aegypti", xlab = "Temperature")
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "2.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"] ~ Temp.xs)
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,42), data = lf.data.comb,
ylab = "Lifespan for Ae. aegypti", xlab = "Temperature")
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "2.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"] ~ Temp.xs)
Temp.xs[which.max(as.vector(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"]))]
lf.grad <- lf.fit$BUGSoutput$sims.list$z.trait.mu.pred
dim(lf.grad) # A matrix with 7500 iterations of the MCMC chains at 226 temperatures
lf.grad
Aaeg.data$trait.name
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
trait
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
data
### Fitting the trait thermal response; Pull out data columns as vectors
data <- MDR.data # this lets us reuse the same generic code: we only change this first line
data
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
jag.data
trait
### Fitting the trait thermal response; Pull out data columns as vectors
data <- MDR.data # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
trait
N.obs <- length(trait)
temp <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
jag.data
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
parameters
temp
N.Temp.xs
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
# Development rate
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data  <- MDR.data # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp  <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
set.seed(1234)
Aaeg.data <- read.csv("Desktop/AedesBayes.csv")
MDR.data <- subset(Aaeg.data, trait.name == "MDR")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, data = MDR.data, ylab="MDR")
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.MDR.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 10 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data  <- MDR.data # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp  <- data$T
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs,
N.Temp.xs = N.Temp.xs)
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
set.seed(1234)
Aaeg.data <- read.csv("Desktop/AedesBayes.csv")
lf.data.comb <- rbind(mu.data.inv, lf.data)
lf.data.comb <- subset(Aaeg.data, trait.name == "MDR")
lf.data.comb
# Parameters to Estimate
parameters <- c("cf.q", "cf.T0", "cf.Tm","cf.sigma", "z.trait.mu.pred")
# Initial values for the parameters
inits<-function(){list(
cf.q = 0.01,
cf.Tm = 35,
cf.T0 = 5,
cf.sigma = rlnorm(1))}
# MCMC Settings: number of posterior dist elements = [(ni - nb) / nt ] * nc
ni <- 25000 # number of iterations in each chain
nb <- 5000 # number of 'burn in' iterations to discard
nt <- 8 # thinning rate - jags saves every nt iterations in each chain
nc <- 3 # number of chains
# Temperature sequence for derived quantity calculations
Temp.xs <- seq(0, 45, 0.2)
N.Temp.xs <-length(Temp.xs)
### Fitting the trait thermal response; Pull out data columns as vectors
data <- lf.data.comb # this lets us reuse the same generic code: we only change this first line
trait <- data$trait
N.obs <- length(trait)
temp <- data$T
data
trait
# Bundle all data in a list for JAGS
jag.data<-list(trait = trait, N.obs = N.obs, temp = temp, Temp.xs = Temp.xs, N.Temp.xs = N.Temp.xs)
jag.data
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
lf.fit <- jags(data=jag.data, inits=inits, parameters.to.save=parameters,
model.file="Desktop/quad.txt", n.thin=nt, n.chains=nc, n.burnin=nb,
n.iter=ni, DIC=T, working.directory=getwd())
lf.fit.mcmc <- as.mcmc(lf.fit)
lf.fit$BUGSoutput$summary[1:5,]
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
pdf=FALSE) ## from the MCMCvis package
s1<-as.data.frame(lf.fit.mcmc[[1]])
par(mfrow=c(3,1))
for(i in c(1,3,4)) acf(s1[,i], lag.max=20)
priors<-matrix(NA, nrow=10000, ncol=3) # 3 params, 1 each
priors[,1]<- runif(10000, min=0, max=1) ## q
priors[,2]<- runif(10000, min=25, max=45) ## TM
priors[,3]<- runif(10000, min=0, max=24) ## T0
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
priors=priors,
post_zm = FALSE,
type= "density",
pdf=FALSE) ## from the MCMCvis package
ipairs(s1[,c(1,3,4)], ztransf = function(x){x[x<1] <- 1; log2(x)})
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
pdf=FALSE) ## from the MCMCvis package
s1<-as.data.frame(lf.fit.mcmc[[1]])
par(mfrow=c(3,1))
for(i in c(1,3,4)) acf(s1[,i], lag.max=20)
priors<-matrix(NA, nrow=10000, ncol=3) # 3 params, 1 each
priors[,1]<- runif(10000, min=0, max=1) ## q
priors[,2]<- runif(10000, min=25, max=45) ## TM
priors[,3]<- runif(10000, min=0, max=24) ## T0
MCMCtrace(lf.fit.mcmc,
params=c("cf.q", "cf.Tm", "cf.T0"),
priors=priors,
post_zm = FALSE,
type= "density",
pdf=FALSE) ## from the MCMCvis package
ipairs(s1[,c(1,3,4)], ztransf = function(x){x[x<1] <- 1; log2(x)})
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,42), data = lf.data.comb,
ylab = "MDR for Ae. aegypti", xlab = "Temperature")
par(mfrow=c(1,1), bty="l")
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,42), data = lf.data.comb,
ylab = "MDR for Ae. aegypti", xlab = "Temperature")
plot(trait ~ T, xlim = c(0, 1), ylim = c(0,42), data = lf.data.comb,
ylab = "MDR for Ae. aegypti", xlab = "Temperature")
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,1), data = lf.data.comb,
ylab = "MDR for Ae. aegypti", xlab = "Temperature")
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "2.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"] ~ Temp.xs)
plot(trait ~ T, xlim = c(0, 45), ylim = c(0,0.2), data = lf.data.comb,
ylab = "MDR for Ae. aegypti", xlab = "Temperature")
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "2.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"] ~ Temp.xs,
lty = 2, col=2, lwd=2)
lines(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"] ~ Temp.xs)
Temp.xs[which.max(as.vector(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "mean"]))]
lf.fit$BUGSoutput$summary
lf.fit$BUGSoutput$summary[6]
Temp.xs[which.max(as.vector(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"]))]
Temp.xs[which.max(as.vector(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "97.5%"]))]
Temp.xs[which.max(as.vector(lf.fit$BUGSoutput$summary[6:(6 + N.Temp.xs - 1), "2.5%"]))]
(40/160)*100
(182/240)*100
160*0.54
240*.88
74*.49
199*.84
160*.09
86*.47
211*.87
36*1
167*.48
14*0
(45/85)*100
(52/75)*100
(42/66)*100
(85/95)*100
(85/93)*100
(85/92)*100
(85/90)*100
24/25*100
85/.9441
(85/90.03284)*100
library(bayesTPC)
library('bayesTPC')
install.packages('bayesTPC')
devtools::install_github()
devtools::install_github('bayesTPC')
?bayesTPC
devtools::install_github(repo = "johnwilliamsmithjr/bayesTPC", auth_token = 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)
devtools::install_github(repo = "johnwilliamsmithjr/bayesTPC", auth_token = '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')
?bayesTPC
??bayesTPC
library(bayesTPC)
?defaultPriors
??defaultPriors
?bayesTPC_summary
library(bayesTPC)
?bayesTPC_summary
update.packages('bayesTPC')
?bayesTPC_summary
?bayesTPC
?bayesTPC::bTPC
install.packages('bayesTPC')
install.packages("bayesTPC")
devtools::install_github(repo = "johnwilliamsmithjr/bayesTPC", auth_token = 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)
require(bayesTPC)
remove.packages('bayesTPC')
install.packages('bayesTPC')
devtools::install_github(repo = "johnwilliamsmithjr/bayesTPC", auth_token = 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)
devtools::install_github(repo = "johnwilliamsmithjr/bayesTPC", auth_token = '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')
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = TRUE) # do not interrupt in case of errors)
#load packages
require(devtools)
require(bayesTPC)
require(coda)
require(nimble)
require(HDInterval)
require(matrixStats)
require(truncnorm)
require(tidyverse)
# fit quadratic TPC model
Temps  = aedesdata$interactor1temp
Traits = 1/aedesdata$originaltraitvalue # note that juvenile mortality is u-shaped so these trait vales must be inverted for fitting most TPC models
aedesQuad = list(Trait = Traits, Temp = as.numeric(Temps))
plot(aedesQuad$Temp, aedesQuad$Trait, col = 'red', xlab = 'Temperature (C)', ylab = 'Trait Value')
aedesQuadFit = bTPC(data = aedesQuad,
model = 'quadratic', niter = 15000,
samplerType = 'AF_slice')
bayesTPC::traceplot(aedesQuadFit)
## set temperature sequence
Temp.seq <- seq(from = 5, to = 35, length.out = 1000)
## generate summary plot for curve using MCMC samples
bayesTPC_summary(TPC = aedesQuadFit,
Temp_interval = Temp.seq,
burn = 2000,
plotOnly = TRUE)
## generate posterior predictive plot
posteriorPredTPC(TPC = aedesQuadFit,
Temp_interval = Temp.seq,
burn = 2000,
plotOnly = TRUE,
seed = 555L)
uninstall('nimble')
remove.packages('nimble')
library(nimble)
install.packages('nimble')
install.packages("nimble")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = TRUE) # do not interrupt in case of errors)
#load packages
require(devtools)
require(bayesTPC)
require(coda)
require(nimble)
require(HDInterval)
require(matrixStats)
require(truncnorm)
require(tidyverse)
# fit quadratic TPC model
Temps  = aedesdata$interactor1temp
Traits = 1/aedesdata$originaltraitvalue # note that juvenile mortality is u-shaped so these trait vales must be inverted for fitting most TPC models
aedesQuad = list(Trait = Traits, Temp = as.numeric(Temps))
plot(aedesQuad$Temp, aedesQuad$Trait, col = 'red', xlab = 'Temperature (C)', ylab = 'Trait Value')
aedesQuadFit = bTPC(data = aedesQuad,
model = 'quadratic', niter = 15000,
samplerType = 'AF_slice')
bayesTPC::traceplot(aedesQuadFit)
## set temperature sequence
Temp.seq <- seq(from = 5, to = 35, length.out = 1000)
## generate summary plot for curve using MCMC samples
bayesTPC_summary(TPC = aedesQuadFit,
Temp_interval = Temp.seq,
burn = 2000,
plotOnly = TRUE)
## generate posterior predictive plot
posteriorPredTPC(TPC = aedesQuadFit,
Temp_interval = Temp.seq,
burn = 2000,
plotOnly = TRUE,
seed = 555L)
require(devtools)
require(bayesTPC)
require(coda)
require(nimble)
require(HDInterval)
require(matrixStats)
require(truncnorm)
require(tidyverse)
# load in some data
aedesdata <- as_tibble(read_csv('Aaegypti.csv'), header = TRUE) %>%
filter(originaltraitname == 'mortality rate')
source("~/Desktop/TraitMismatchPaper-main/code/01_AllTraitTPCFitting.R")
setwd("~/Desktop/TraitMismatchPaper-main/data")
source("~/Desktop/TraitMismatchPaper-main/code/01_AllTraitTPCFitting.R")
