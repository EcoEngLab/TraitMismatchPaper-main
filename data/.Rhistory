theme_bw() +
theme(legend.position = 'none')
#get good names with line break
dv$GoodName <- str_replace(pattern = " ",replacement =  "\n", dv$species)
#fit models
FitModel <- function(ID){
# browser()
ID <<- ID
df <- dv %>% filter(curve_ID == ID)
df <<-df
Model <- tryCatch({minpack.lm::nlsLM(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = df,
start = coef(dv_fits$fit[[which(dv_fits$curve_ID==ID)]]),
lower = get_lower_lims(df$temp, df$rate, model_name = 'pawar_2018'),
upper = get_upper_lims(df$temp, df$rate, model_name = 'pawar_2018'),
weights = rep(1, times = nrow(df)))
}, error = function(error){
print(paste("error in:", ID, ",", error))
minpack.lm::nlsLM(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = df,
start = coef(dv_fits$fit[[which(dv_fits$curve_ID==ID)]]),
weights = rep(1, times = nrow(df)))
})
extra_params <- calc_params(Model) %>%
pivot_longer(everything(), names_to =  'param', values_to = 'estimate')
ci_extra_params <- Boot(Model, f = function(x){unlist(calc_params(x))}, labels = names(calc_params(Model)), R = 200, method = 'residual')%>%
confint(., method = 'bca')%>%
as.data.frame() %>%
rename(conf_lower = 1, conf_upper = 2) %>%
rownames_to_column(., var = 'param') %>%
mutate(method = 'residual bootstrap')
ci_extra_params <- left_join(ci_extra_params, extra_params)
##Get other parameters
params <- broom::tidy(Model) %>% select(param = term, estimate)
BootOut <- Boot(Model, method = 'residual')
## Get the param Names that has multiple values:
paramName <- colnames(BootOut[[2]])[which(apply(BootOut[[2]], 2, function(x) length(unique(x))>1))]
params_cis <- BootOut %>%
confint(.,parm = paramName, method = 'bca') %>%
as.data.frame() %>%
rename(conf_lower = 1, conf_upper = 2) %>%
rownames_to_column(., var = 'param') %>%
mutate(method = 'residual bootstrap')
params_cis <- bind_rows(params_cis) %>%
left_join(., params)%>%
filter(param!="topt")
topt <- as_tibble(rbind(ci_extra_params,params_cis))
topt$species <- as.character(df$species[1])
#Plot fit
Boot_conf <- BootOut$t %>%
as.data.frame() %>%
drop_na() %>%
mutate(iter = 1:n()) %>%
group_by_all() %>%
do(data.frame(temp = seq(min(0), max(45), length.out = 1000))) %>%
ungroup() %>%
mutate(pred =pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15))
# calculate bootstrapped confidence intervals
boot_conf_preds <- group_by(Boot_conf, temp) %>%
summarise(conf_lower = quantile(pred, 0.025),
conf_upper = quantile(pred, 0.975)) %>%
ungroup()
##plot
counter <- which(dv_fits$curve_ID==ID)
print(counter)
plotData <- filter(dv_preds, dv_preds$curve_ID==ID)
plot <- ggplot(data=df, aes(x=temp, y=rate))+
geom_point()+
geom_line(data=plotData, mapping = aes(x=temp, y=.fitted)) +
geom_ribbon(aes(temp, ymin=conf_lower, ymax=conf_upper), boot_conf_preds, fill="#e66101",alpha=0.3,
inherit.aes = F)+
theme_bw()+
theme(text = element_text(size=10))+
labs(title=paste(df$GoodName[1], sep=""),
y="metabolic rate", x=expression(plain(paste(" Temperature, ",degree,"C"))))
ggsave(plot,file=paste("MR_",ID,".pdf",sep=""),
height=10,width=15,units="cm")
AlphaPlots[[counter]] <<- plot
return(topt)
}
AlphaPlots <- vector(mode="list", length=length(unique(dv$curve_ID)))
ModelOut       <- sapply(unique(dv$curve_ID), FitModel)
View(dv_preds)
View(dv_preds)
##Run everything using apply:
AlphaPlots <- vector(mode="list", length=length(unique(dv$curve_ID)))
ModelOut       <- sapply(unique(dv$curve_ID), FitModel)
rm(list=ls())
graphics.off()
df <- as_tibble(read.csv('MRData.csv'))
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
low_lims <-   get_lower_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
upper_lims <- get_upper_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
View(dv)
rm(list=ls())
graphics.off()
df <- as_tibble(read.csv('MRData.csv'))
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult', trait == 'metabolic rate') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
rm(list=ls())
graphics.off()
df <- as_tibble(read.csv('MRData.csv'))
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult', originaltraitname == 'metabolic rate') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
low_lims <-   get_lower_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
upper_lims <- get_upper_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult', originaltraitname == 'metabolic rate') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
low_lims <-   get_lower_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
upper_lims <- get_upper_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
View(dv)
View(dv)
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult',
originaltraitname == 'metabolic rate', notes == 'constant thermal regimes') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage, notes) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult',
originaltraitname == 'metabolic rate', notes == 'constant thermal regimes') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
low_lims <-   get_lower_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
upper_lims <- get_upper_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
rm(list=ls())
graphics.off()
df <- as_tibble(read.csv('MRData.csv'))
# Prepare data and filter out species that we won't be able fit *unimodal* TPCs for
dv <- df %>% rename(temp = interactor1temp, species = interactor1, rate = originaltraitvalue, stage = interactor1stage) %>%
select(species, temp, originaltraitname, rate, stage, notes) %>%
filter(species == 'Alphitobius diaperinus', stage == 'adult',
originaltraitname == 'metabolic rate', notes == 'constant thermal regimes') %>%
mutate(curve_ID = case_when(species == 'Alphitobius diaperinus' ~ '1')) %>%
mutate(temp = as.numeric(temp), rate = as.numeric(rate))
# fit TPC model for each species
start_vals <- get_start_vals(dv$temp, dv$rate, model_name = 'pawar_2018')
low_lims <-   get_lower_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
upper_lims <- get_upper_lims(dv$temp, dv$rate, model_name = 'pawar_2018')
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
start_lower = start_vals - 10,
start_upper = start_vals + 10,
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
start_vals
low_lims
dv_fits <- nest(dv, data = c(temp, rate)) %>%
mutate(fit = map(data, ~nls_multstart(rate~pawar_2018(temp = temp, r_tref,e,eh,topt, tref = 15),
data = .x,
iter = c(3,3,3,3),
start_lower = start_vals - 1,
start_upper = start_vals + 1,
lower = low_lims,
upper= upper_lims,
supp_errors = 'Y',
convergence_count = FALSE)))
View(dv)
View(dv)
setwd("~/Desktop/TraitMismatchPaper-main/data")
# load packages
library(rTPC)
library(nls.multstart)
library(broom)
library(tidyverse)
library(ggrepel)
library(MuMIn)
library(ggplot2)
grand_split <- function(dataset)
{
split_dataset <- list()
# Unique Spp.
unique_Sp <- unique(dataset$DataSeriesID)
for ( i in unique_Sp ){
temp_dataset <- dataset[dataset$DataSeriesID == i,]
unique_temps <- unique(temp_dataset$temp)
for ( j in unique_temps) {
temp_dataset2 <- temp_dataset[temp_dataset$temp == j,]
name <- paste(i, as.character(j), sep = "_")
split_dataset[[name]] <- temp_dataset2
}
}
return(split_dataset)
}
# This function is the rm equation.
# rm =  max pop growth rate, Topt = temp at which rm peaks, rm(opt) = rm at Topt
# k = age specific fecundity loss rate
# a = maturation time
# bmax = max fecundity
# zj = juvenile mortality rate
# z = adult mortality rate
rm_equation <- function(a, bmax, z, zj)
{
rm <- (z * (log(bmax/z) - (a*zj))) / (a * z + 1)
return(rm)
}
# This function applies the rm equation to a dataset.
rm_calculation <- function(dataset)
{
results <- data.frame()
rm <- 0
a <- 0
bmax <- 0
z <- 0
zj <- 0
if (nrow(dataset) == 4){
#
# Calculating alpha #######
#
temp_rows <- dataset[dataset$standardisedtraitname == "1/alpha",]
temp_rows$reciprocal <- (temp_rows$trait_value)^-1
a <- temp_rows$reciprocal
#
# Calculating bmax, z, zj #######
#
temp_rows2 <- dataset[dataset$standardisedtraitname == "bmax",]
bmax <- temp_rows2$trait_value
temp_rows3 <- dataset[dataset$standardisedtraitname == "z",]
z <- temp_rows3$trait_value
temp_rows4 <- dataset[dataset$standardisedtraitname == "zj",]
zj <- temp_rows4$trait_value
#
# Calculating rm #######
#
rm <- rm_equation(a, bmax, z, zj)
#
# Storing values into dataframe #######
#
temp_df <- data.frame(unique(dataset$DataSeriesID), unique(dataset$temp),
rm, a, bmax, z, zj)
results <- rbind(results, temp_df)
} else {
rm <- NA
a <- NA
bmax <- NA
z <- NA
zj <- NA
temp_df <- data.frame(unique(dataset$DataSeriesID), unique(dataset$temp),
rm, a, bmax, z, zj)
results <- rbind(results, temp_df)
}
return(results)
}
# MAIN CODE ###################################################################
# Species with all 4 statistics - notice lack of Aedes aegypti
ids <- c("Acyrthosiphon pisum", "Anoplophora glabripennis", "Anthonomus grandis",
"Aphis gossypii", "Aphis nasturtii", "Bemisia tabaci", "Halyomorpha halys",
"Helicoverpa armigera", "Muscidifurax zaraptor", "Paracoccus marginatus",
"Rhopalosiphum maidis", "Stethorus punctillum", "Tetraneura nigriabdominalis",
"Tetranychus mcdanieli", "Thrips hawaiiensis")
# load in data
all_data <- read.csv("data/TraitData.csv")
# load in data
all_data <- read.csv("TraitData.csv")
all_data$DataSeriesID <- all_data$interactor1
all_data$trait_value <- all_data$standardisedtraitvalue
all_data$temp <- as.numeric(all_data$interactor1temp)
data <- all_data[, c('DataSeriesID', 'trait_value', 'temp', 'standardisedtraitname')]
data <- na.omit(data)
rm(all_data)
View(data)
# keep only data with the above species IDs
data <- subset(data, DataSeriesID %in% ids, )
# Data has been split in IDs & temps ###########
split.data <- grand_split(data)
View(split.data)
# Calculating rm for each ID & temperature
rm <- data.frame()
for (i in split.data){
rm2 <- rm_calculation(i)
rm <- rbind(rm, rm2)
}
# Values for rm calculated
rm <- na.omit(rm)
rm <- rm[,c(1, 2, 3)]
colnames(rm) <- c("DataSeriesID", "temp", "rm")
for (id in ids){
temp_id <- filter(rm, DataSeriesID == id)
}
# rm MAX & corresponding temperature for each species
rmsplit <- split(rm, rm$DataSeriesID)
rm_max_list <- data.frame(matrix(ncol = 3, nrow = 0))
colnames(rm_max_list) <- c("DataSeriesID", "temp", "rm") # New dataframe for storage of rm Max
for (species in rmsplit){
tempdf <- species[species$rm == max(species$rm), ]
rm_max_list <- rbind(rm_max_list, tempdf)
}
# Plot results
ggplot(rm_max_list, aes(temp, log(rm)), group = DataSeriesID) + geom_point(aes(shape=DataSeriesID, fill=DataSeriesID),size = 3) +
scale_shape_manual(values = c(21,21,21,22,22,22,22,23,23,23,23,24,24,24,24)) +
scale_fill_manual(values = c("#d2d2d2", "#515151", "#000000", "#d2d2d2", "#929292", "#515151", "#000000", "#d2d2d2", "#929292", "#515151", "#000000", "#d2d2d2", "#929292", "#515151", "#000000"))
log(-4)
exp(-4)
exp(-2)
exp(-1)
View(rm_max_list)
View(split.data)
rm
#
#
# load in data
all_data              <- read.csv("TraitData.csv")
all_data$DataSeriesID <- all_data$interactor1
all_data$trait_value  <- all_data$standardisedtraitvalue
all_data$temp         <- as.numeric(all_data$interactor1temp)
data <- all_data[, c('DataSeriesID', 'trait_value', 'temp', 'standardisedtraitname')]
data <- na.omit(data)
rm(all_data)
# keep just a single curve
d1 <- filter(data, standardisedtraitname == "zj") # Change as necessary (a, bmax, z, zj)
d1$trait_value <- 1/(d1$trait_value)
unique.ids <- unique(d1$DataSeriesID)
mod = 'sharpeschoolfull_1981'
for (id in unique.ids){
d <- filter(d1, DataSeriesID == id)
# get start vals
start_vals <- get_start_vals(d$temp, d$trait_value, model_name = mod)
# get limits
low_lims <- get_lower_lims(d$temp, d$trait_value, model_name = mod)
upper_lims <- get_upper_lims(d$temp, d$trait_value, model_name = mod)
start_vals
low_lims
upper_lims
#
#
# fit model
fit <- nls_multstart(trait_value~sharpeschoolfull_1981(temp = temp, r_tref,e,el,tl,eh,th, tref = 15),
data = d,
iter = 500,
start_lower = start_vals -10,
start_upper = start_vals +10,
lower = low_lims,
upper = upper_lims,
supp_errors = 'Y')
if (is.null(fit) == T){
cat(id, "does not fit the model", "\n")
}else{
cat("Success", id, "\n")
# calculate additional traits
calc_params(fit) %>%
# round for easy viewing
mutate_all(round, 2)
# predict new data
new_data <- data.frame(temp = seq(min(d$temp), max(d$temp), 0.5))
preds <- augment(fit, newdata = new_data)
# plot data and model fit
bruh_plot <- ggplot(d, aes(temp, trait_value)) +
geom_point() +
geom_line(aes(temp, .fitted), preds, col = 'blue') +
theme_bw(base_size = 12) +
labs(x = 'Temperature (ºC)', y = 'z', title = id) #Change as necessary
plot(bruh_plot)
ggsave(filename = paste(id, "zj.jpeg"), device = "jpeg", path = "results/model_fits/zj")
}
}
#
#
# fit model
fit <- nls_multstart(trait_value~sharpeschoolfull_1981(temp = temp, r_tref,e,el,tl,eh,th, tref = 15),
data = d,
iter = 500,
start_lower = start_vals -10,
start_upper = start_vals +10,
lower = low_lims,
upper = upper_lims,
supp_errors = 'Y')
if (is.null(fit) == T){
cat(id, "does not fit the model", "\n")
}else{
cat("Success", id, "\n")
# calculate additional traits
calc_params(fit) %>%
# round for easy viewing
mutate_all(round, 2)
# predict new data
new_data <- data.frame(temp = seq(min(d$temp), max(d$temp), 0.5))
preds <- augment(fit, newdata = new_data)
# plot data and model fit
bruh_plot <- ggplot(d, aes(temp, trait_value)) +
geom_point() +
geom_line(aes(temp, .fitted), preds, col = 'blue') +
theme_bw(base_size = 12) +
labs(x = 'Temperature (ºC)', y = 'z', title = id) #Change as necessary
plot(bruh_plot)
ggsave(filename = paste(id, "zj.jpeg"), device = "jpeg", path = "results/model_fits/zj")
}
View(d)
View(d1)
#
#
# load in data
all_data              <- read.csv("TraitData.csv")
all_data$DataSeriesID <- all_data$interactor1
all_data$trait_value  <- all_data$standardisedtraitvalue
all_data$temp         <- as.numeric(all_data$interactor1temp)
data <- all_data[, c('DataSeriesID', 'trait_value', 'temp', 'standardisedtraitname')]
data <- na.omit(data)
rm(all_data)
# keep just a single curve
d1 <- filter(data, standardisedtraitname == "zj") # Change as necessary (a, bmax, z, zj)
d1$trait_value <- 1/(d1$trait_value)
View(d1)
unique.ids <- unique(d1$DataSeriesID)
filter(d1, DataSeriesID == id)
filter(d2, DataSeriesID == id)
for (id in unique.ids){
d <- filter(d1, DataSeriesID == id)
# get start vals
start_vals <- get_start_vals(d$temp, d$trait_value, model_name = mod)
# get limits
low_lims <- get_lower_lims(d$temp, d$trait_value, model_name = mod)
upper_lims <- get_upper_lims(d$temp, d$trait_value, model_name = mod)
start_vals
low_lims
upper_lims
#
#
# fit model
fit <- nls_multstart(trait_value~sharpeschoolfull_1981(temp = temp, r_tref,e,el,tl,eh,th, tref = 15),
data = d,
iter = 500,
start_lower = start_vals -10,
start_upper = start_vals +10,
lower = low_lims,
upper = upper_lims,
supp_errors = 'Y')
if (is.null(fit) == T){
cat(id, "does not fit the model", "\n")
}else{
cat("Success", id, "\n")
# calculate additional traits
calc_params(fit) %>%
# round for easy viewing
mutate_all(round, 2)
# predict new data
new_data <- data.frame(temp = seq(min(d$temp), max(d$temp), 0.5))
preds <- augment(fit, newdata = new_data)
# plot data and model fit
bruh_plot <- ggplot(d, aes(temp, trait_value)) +
geom_point() +
geom_line(aes(temp, .fitted), preds, col = 'blue') +
theme_bw(base_size = 12) +
labs(x = 'Temperature (ºC)', y = 'zj', title = id) # Change as necessary
plot(bruh_plot)
ggsave(filename = paste(id, "zj.jpeg"), device = "jpeg", path = "results/model_fits/zj")
}
}
